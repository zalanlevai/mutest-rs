use smallvec::{SmallVec, smallvec};

use crate::codegen::ast;
use crate::codegen::ast::P;
use crate::codegen::ast::entry::EntryPointType;
use crate::codegen::ast::mut_visit::{ExpectOne, MutVisitor};
use crate::codegen::symbols::sym;

fn entry_point_type(item: &ast::Item, depth: usize) -> EntryPointType {
    match &item.kind {
        ast::ItemKind::Fn(fn_item) => {
            if item.attrs.iter().any(|attr| attr.has_name(sym::rustc_main)) {
                EntryPointType::RustcMainAttr
            } else if fn_item.ident.name == sym::main {
                if depth == 0 {
                    EntryPointType::MainNamed
                } else {
                    EntryPointType::OtherMain
                }
            } else {
                EntryPointType::None
            }
        }
        _ => EntryPointType::None,
    }
}

struct EntryPointCleaner {
    depth: usize,
}

impl ast::mut_visit::MutVisitor for EntryPointCleaner {
    fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {
        self.depth += 1;
        let item = ast::mut_visit::walk_flat_map_item(self, i).expect_one("noop did something");
        self.depth -= 1;

        let item = item.into_inner();

        match entry_point_type(&item, self.depth) {
            // Retain items that are user-defined entry points.
            EntryPointType::MainNamed => {}
            // Drop the entry point generated by the rustc test harness, which is marked with `#[rustc_main]`.
            EntryPointType::RustcMainAttr => return smallvec![],
            // Ignore items that are not entry points.
            EntryPointType::None | EntryPointType::OtherMain => {}
        };

        smallvec![P(item)]
    }
}

pub fn clean_generated_entry_points(krate: &mut ast::Crate) {
    let mut cleaner = EntryPointCleaner { depth: 0 };
    cleaner.visit_crate(krate);
}
