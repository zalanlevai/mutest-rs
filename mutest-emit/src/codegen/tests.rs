use std::iter;

use itertools::Itertools;
use rustc_ast as ast;
use rustc_ast::entry::EntryPointType;
use rustc_ast::mut_visit::{ExpectOne, MutVisitor};
use rustc_ast::ptr::P;
use rustc_expand::base::ExtCtxt;
use rustc_session::Session;
use rustc_span::{DUMMY_SP, Span, Symbol, sym};
use rustc_span::hygiene::AstPass;
use rustc_span::symbol::Ident;
use smallvec::{SmallVec, smallvec};

use crate::analysis::tests::Test;

fn is_cfg_test_attr(attr: &ast::Attribute) -> bool {
    // `#[cfg(test)]`
    attr.has_name(sym::cfg) && attr.meta_item_list().is_some_with(|list| list.iter().any(|item| item.has_name(sym::test)))
}

fn unambiguous_test_item_ident(ident: &Ident) -> Ident {
    let symbol = Symbol::intern(&format!("{}_impl", ident));
    Ident::new(symbol, ident.span)
}

fn is_test_extern_crate_decl(item: &ast::Item) -> bool {
    if let ast::ItemKind::ExternCrate(..) = item.kind {
        if item.ident.name == sym::test {
            return true;
        }
    }

    false
}

fn dedupe_test_extern_crate_decls(items: &mut Vec<P<ast::Item>>) {
    if let Some((first_extern_crate_index, _)) = items.iter().find_position(|&item| is_test_extern_crate_decl(item)) {
        let mut i = first_extern_crate_index + 1;

        while let Some(item) = items.get(i) {
            if !is_test_extern_crate_decl(item) {
                i += 1;
                continue;
            }

            items.remove(i);
        }
    }
}

struct TestCaseCleaner<'ecx, 'op, 'tst> {
    ecx: &'op mut ExtCtxt<'ecx>,
    tests: &'tst Vec<Test>,
}

impl MutVisitor for TestCaseCleaner<'_, '_, '_> {
    fn visit_crate(&mut self, c: &mut ast::Crate) {
        ast::mut_visit::noop_visit_crate(c, self);

        dedupe_test_extern_crate_decls(&mut c.items);
    }

    fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {
        let mut item = i.into_inner();

        if let ast::ItemKind::Mod(..) = item.kind {
            ast::mut_visit::noop_visit_item_kind(&mut item.kind, self);

            // // FIXME: Tests are commonly written in private test modules which have a
            // //        `#cfg[test]` attribute. This prevents us from addressing them even
            // //        when using their full paths. Resolving these on all test modules
            // //        (and their ancestors) would be possile, but it would change the name
            // //        resolution behaviour of the generated program compared to the
            // //        original. Test case addressing will have to be solved another way,
            // //        potentially by reusing the built-in test harness generation with a
            // //        custom test runner.
            // {
            //     item.attrs = item.attrs.into_iter()
            //         // Remove the `#[cfg(test)]` attribute commonly added to test modules.
            //         .filter(|attr| !is_cfg_test_attr(attr))
            //         .collect();
            //
            //     item.vis.kind = ast::VisibilityKind::Public;
            // }

            if let ast::ItemKind::Mod(_, ast::ModKind::Loaded(ref mut items, _, _)) = item.kind {
                dedupe_test_extern_crate_decls(items);
            }
        }

        if let Some(test) = self.tests.iter().find(|&test| test.descriptor.id == item.id) {
            item.attrs = item.attrs.into_iter()
                // Remove the `#[cfg(test)]` attribute generated by the rustc test harness.
                .filter(|attr| !is_cfg_test_attr(attr))
                .collect();

            if let ast::ItemKind::Const(_, _, Some(ref mut test_const_expr)) = item.kind
                && let ast::ExprKind::Struct(ref mut test_const_struct_expr) = test_const_expr.kind
                && let Some(test_fn_field) = test_const_struct_expr.fields.iter_mut().find(|field| field.ident.name == Symbol::intern("testfn"))
                && let ast::ExprKind::Call(_, ref mut test_lib_call_args) = test_fn_field.expr.kind
                && let Some(test_lib_call_lambda) = test_lib_call_args.first_mut()
                && let ast::ExprKind::Closure(_, _, _, _, ref mut test_lib_call_body, _) = test_lib_call_lambda.kind
                && let ast::ExprKind::Call(_, ref mut test_assert_call_args) = test_lib_call_body.kind
                && let Some(test_fn_call) = test_assert_call_args.first_mut()
                && let ast::ExprKind::Call(ref mut test_fn_path, _) = test_fn_call.kind
                && let ast::ExprKind::Path(_, ref mut test_fn_path) = test_fn_path.kind
            {
                *test_fn_path = self.ecx.path(test_fn_path.span, vec![unambiguous_test_item_ident(&test.descriptor.ident)]);
            }
        }

        if let Some(test) = self.tests.iter().find(|&test| test.item.id == item.id) {
            item.ident = unambiguous_test_item_ident(&test.descriptor.ident);
        }

        smallvec![P(item)]
    }
}

pub fn clean_up_test_cases(ecx: &mut ExtCtxt<'_>, tests: &Vec<Test>, krate: &mut ast::Crate) {
    let mut cleaner = TestCaseCleaner { ecx, tests };
    cleaner.visit_crate(krate);
}

// Beware, this is duplicated in librustc_passes/entry.rs (with
// `rustc_hir::Item`), so make sure to keep them in sync.
fn entry_point_type(sess: &Session, item: &ast::Item, depth: usize) -> EntryPointType {
    match item.kind {
        ast::ItemKind::Fn(..) => {
            if sess.contains_name(&item.attrs, sym::start) {
                EntryPointType::Start
            } else if sess.contains_name(&item.attrs, sym::rustc_main) {
                EntryPointType::MainAttr
            } else if item.ident.name == sym::main {
                if depth == 0 {
                    EntryPointType::MainNamed
                } else {
                    EntryPointType::OtherMain
                }
            } else {
                EntryPointType::None
            }
        }
        _ => EntryPointType::None,
    }
}

fn is_allow_dead_code_attr(attr: &ast::Attribute) -> bool {
    // `#[allow(dead_code)]`
    attr.has_name(sym::allow) && attr.meta_item_list().is_some_with(|list| list.iter().any(|item| item.has_name(sym::dead_code)))
}

struct EntryPointCleaner<'a> {
    sess: &'a Session,
    depth: usize,
}

impl MutVisitor for EntryPointCleaner<'_> {
    fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {
        self.depth += 1;
        let item = ast::mut_visit::noop_flat_map_item(i, self).expect_one("noop did something");
        self.depth -= 1;

        let mut item = item.into_inner();

        match entry_point_type(self.sess, &item, self.depth) {
            // Retain items that are user-defined entry points as dead-code.
            EntryPointType::MainNamed | EntryPointType::Start => {
                if item.ident.name == sym::main {
                    let symbol = Symbol::intern("unused_main");
                    item.ident = Ident::new(symbol, item.ident.span);
                }

                let allow_dead_code_attr = ast::attr::mk_attr_outer(ast::attr::mk_list_item(
                    Ident::new(sym::allow, item.span),
                    vec![ast::attr::mk_nested_word_item(Ident::new(sym::dead_code, item.span))],
                ));

                item.attrs = item.attrs.into_iter()
                    .filter(|attr| !attr.has_name(sym::start))
                    // Remove any existing `#[allow(dead_code)]` attributes (e.g. those generated by the rustc test harness).
                    .filter(|attr| !is_allow_dead_code_attr(attr))
                    .chain(iter::once(allow_dead_code_attr))
                    .collect();
            }
            // Drop the entry point generated by the rustc test harness, which is marked with `#[rustc_main]`.
            EntryPointType::MainAttr => return smallvec![],
            // Ignore items that are not entry points.
            EntryPointType::None | EntryPointType::OtherMain => {}
        };

        smallvec![P(item)]
    }
}

pub fn clean_entry_points(sess: &Session, krate: &mut ast::Crate) {
    let mut cleaner = EntryPointCleaner { sess, depth: 0 };
    cleaner.visit_crate(krate);
}

struct DummyMainGenerator<'ecx, 'op> {
    ecx: &'op mut ExtCtxt<'ecx>,
    def_site: Span,
}

impl MutVisitor for DummyMainGenerator<'_, '_> {
    fn visit_crate(&mut self, c: &mut ast::Crate) {
        ast::mut_visit::noop_visit_crate(c, self);

        let def = self.def_site;

        // pub fn main() {}
        let main = ast::Item {
            id: ast::DUMMY_NODE_ID,
            span: def,
            attrs: vec![],
            vis: ast::Visibility { span: def, kind: ast::VisibilityKind::Public, tokens: None },
            ident: Ident::new(sym::main, def),
            kind: ast::ItemKind::Fn(Box::new(ast::Fn {
                defaultness: ast::Defaultness::Final,
                generics: Default::default(),
                sig: ast::FnSig {
                    span: def,
                    header: ast::FnHeader::default(),
                    decl: self.ecx.fn_decl(
                        vec![],
                        ast::FnRetTy::Default(def),
                    ),
                },
                body: Some(self.ecx.block(def, vec![])),
            })),
            tokens: None,
        };

        c.items.push(P(main));
    }
}

pub fn generate_dummy_main(ecx: &mut ExtCtxt<'_>, krate: &mut ast::Crate) {
    let expn_id = ecx.resolver.expansion_for_ast_pass(
        DUMMY_SP,
        AstPass::TestHarness,
        &[sym::test, sym::rustc_attrs],
        None,
    );
    let def_site = DUMMY_SP.with_def_site_ctxt(expn_id.to_expn_id());

    let mut generator = DummyMainGenerator { ecx, def_site };
    generator.visit_crate(krate);
}

struct DummyMainRemover;

impl MutVisitor for DummyMainRemover {
    fn visit_crate(&mut self, c: &mut ast::Crate) {
        ast::mut_visit::noop_visit_crate(c, self);

        c.items.retain(|item| item.ident.name != sym::main)
    }
}

pub fn remove_dummy_main(krate: &mut ast::Crate) {
    let mut remover = DummyMainRemover;
    remover.visit_crate(krate);
}
